# .github/workflows/auto-label.yml
name: "ðŸ·ï¸ Auto Label Issues"

on:
  issues:
    types: [opened, edited]
  pull_request:
    types: [opened, edited]

jobs:
  auto-label:
    runs-on: ubuntu-latest
    permissions:
      issues: write
      pull-requests: write

    steps:
      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ðŸ·ï¸ Auto label issues
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue || context.payload.pull_request;
            const title = issue.title.toLowerCase();
            const body = (issue.body || '').toLowerCase();
            const content = `${title} ${body}`;
            
            const labelsToAdd = [];
            
            // Type detection
            if (content.includes('[setup]') || content.includes('setup')) {
              labelsToAdd.push('type:infrastructure');
            }
            if (content.includes('[types]') || content.includes('type definitions')) {
              labelsToAdd.push('type:feature');
            }
            if (content.includes('[migration]') || content.includes('migrate')) {
              labelsToAdd.push('type:refactor');
            }
            if (content.includes('[rpc]') || content.includes('json-rpc')) {
              labelsToAdd.push('type:feature');
            }
            if (content.includes('[storage]')) {
              labelsToAdd.push('type:feature');
            }
            if (content.includes('[testing]') || content.includes('test')) {
              labelsToAdd.push('type:test');
            }
            if (content.includes('[docs]') || content.includes('documentation')) {
              labelsToAdd.push('type:docs');
            }
            if (content.includes('[performance]')) {
              labelsToAdd.push('type:enhancement');
            }
            if (content.includes('[release]')) {
              labelsToAdd.push('type:operations');
            }
            if (content.includes('[integration]')) {
              labelsToAdd.push('type:test');
            }
            
            // Priority detection
            if (content.includes('high priority') || content.includes('urgent')) {
              labelsToAdd.push('priority:high');
            } else if (content.includes('low priority')) {
              labelsToAdd.push('priority:low');
            } else {
              labelsToAdd.push('priority:medium');
            }
            
            // Status detection
            if (content.includes('blocked') || content.includes('waiting')) {
              labelsToAdd.push('status:blocked');
            } else if (content.includes('ready')) {
              labelsToAdd.push('status:ready');
            }
            
            // Remove duplicates
            const uniqueLabels = [...new Set(labelsToAdd)];
            
            if (uniqueLabels.length > 0) {
              if (context.payload.issue) {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  labels: uniqueLabels,
                });
                console.log(`Added labels to issue #${issue.number}: ${uniqueLabels.join(', ')}`);
              } else if (context.payload.pull_request) {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  labels: uniqueLabels,
                });
                console.log(`Added labels to PR #${issue.number}: ${uniqueLabels.join(', ')}`);
              }
            }